## application.yaml

```yaml
server:
    port: ${doj.port.gateway-service}
doj:
    auth:
        excludePaths:
            - /
            - /static/**
            - /user/login
            - /user/register
            - /user/refresh
```

excludePaths表示不需要进行路由拦截（过滤）的请求。

因为gateway存在时，我们希望**所有的请求都需要经过gateway**，这样我们才能实现对所有访问微服务的请求都进行权限(身份)认证。

我们在gateway中主要验证用户的JWT Token

```java
public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String path = exchange.getRequest().getURI().getPath();
        if (isExcludedPath(path)) {
            ServerWebExchange build = exchange.mutate()
                    .request(builder -> builder.header(jwtProperties.getSecretKey(), String.valueOf(0)))
                    .build();
            return chain.filter(build);
        }
        log.info("path:{}", path);
        log.info("headers:{}", exchange.getRequest().getHeaders().entrySet());
        String token = exchange.getRequest().getHeaders().getFirst(jwtProperties.getAuthorization());
        Long userId;
        try {
            userId = jwtTool.parseToken(token);
        } catch (UnauthorizedException e) {
            return handleUnauthorizedResponse(exchange);
        }
        // 校验成功，将userId放入请求头
        ServerWebExchange build = exchange.mutate()
                .request(builder -> builder.header(jwtProperties.getSecretKey(), String.valueOf(userId)))
                .build();
        return chain.filter(build);
    }
}
```

> 后面user-service中用户登录时会绑定JWT Token

## bootstrap.yaml

```yaml
spring:
    application:
        name: gateway-service
    profiles:
        active: dev, common
    cloud:
        nacos:
            server-addr: 127.0.0.1:8848
            config:
                file-extension: yaml
                shared-configs:
                    -   dataId: shared-jwt.yaml
        gateway:
            routes:
                -   id: user
                    uri: lb://user-service
                    predicates:
                        - Path=/user/**,/static/**
                -   id: problem
                    uri: lb://problem-service
                    predicates:
                        - Path=/problem/**
                -   id: sandbox
                    uri: lb://sandbox-service
                    predicates:
                        - Path=/sandbox/**
                -   id: submission
                    uri: lb://submission-service
                    predicates:
                        - Path=/submission/**
```

每个路由包含：

- `id`: 路由 ID，唯一标识
- `uri`: 服务地址，`lb://` 表示使用服务发现（LoadBalancer），服务名由注册中心（如 Nacos）识别
- `predicates`: 路由谓词，决定哪些请求会命中该路由（比如根据路径）

## Sentinel 配置

为了实现流量治理，网关集成了 Sentinel，并将规则持久化到 Nacos。

### `application.yaml` 配置

```yaml
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8858 # 指向 Sentinel 控制台地址
      datasource:
        # 流控规则数据源
        flow:
          nacos:
            server-addr: ${spring.cloud.nacos.server-addr}
            data-id: gateway-sentinel-rules
            rule-type: flow
            # ...
        # 熔断降级规则数据源
        degrade:
          nacos:
            server-addr: ${spring.cloud.nacos.server-addr}
            data-id: gateway-sentinel-degrade-rules
            rule-type: degrade
            # ...
```

- **`transport.dashboard`**: 配置 Sentinel 控制台的地址和端口。
- **`datasource`**: 配置动态规则的数据源。我们配置了两个 Nacos 数据源，分别用于加载**流控规则** (`flow`) 和**熔断降级规则** (`degrade`)。

### Nacos 中的规则示例

- **`gateway-sentinel-rules` (流控)**: 用于配置 QPS 限制等规则。
- **`gateway-sentinel-degrade-rules` (熔断)**: 用于配置慢调用、异常比例等熔断策略。

通过这种方式，所有流量治理规则都实现了集中化、动态化和持久化管理。