SET NAMES utf8mb4;

DROP TABLE IF EXISTS problem_tag;
DROP TABLE IF EXISTS tag;
DROP TABLE IF EXISTS problem;

CREATE TABLE problem (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(128) NOT NULL,
  description MEDIUMTEXT NOT NULL,
  input_style TEXT NOT NULL,
  output_style TEXT NOT NULL,
  input_sample JSON NOT NULL,
  output_sample JSON NOT NULL,
  difficulty VARCHAR(10) NOT NULL,
  time_limit INT NOT NULL,
  memory_limit INT NOT NULL,
  hint TEXT,
  total_pass INT NOT NULL DEFAULT 0,
  total_attempt INT NOT NULL DEFAULT 0,
  test_data LONGTEXT NOT NULL,
  test_ans LONGTEXT NOT NULL,
  INDEX idx_problem_difficulty (difficulty)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE tag (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(64) NOT NULL UNIQUE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE problem_tag (
  problem_id BIGINT NOT NULL,
  tag_id BIGINT NOT NULL,
  PRIMARY KEY (problem_id, tag_id),
  INDEX idx_tag_id (tag_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

INSERT INTO tag (id, name) VALUES
(1, '入门'),
(2, '模拟'),
(3, '动态规划'),
(4, '数组'),
(5, '栈'),
(6, '字符串'),
(7, '矩阵'),
(8, '二分'),
(9, '有序'),
(10, '排序'),
(11, '区间'),
(12, '网格'),
(13, '图论'),
(14, '拓扑排序'),
(15, '最小生成树'),
(16, '最短路径'),
(17, '数学'),
(18, '基础'),
(19, '双指针'),
(20, '分治'),
(21, '归并排序'),
(22, '前缀和'),
(23, 'DFS'),
(24, 'BFS'),
(25, '数论');

INSERT INTO problem (
  id, name, description, input_style, output_style, input_sample, output_sample,
  difficulty, time_limit, memory_limit, hint, total_pass, total_attempt, test_data, test_ans
) VALUES
(1, 'A+B Problem',
 '给定两个整数 A 和 B，输出它们的和。\n\n**任务**\n- 读取两个整数并计算 A+B。\n- 结果可能为负数。',
 '- 一行包含两个整数 A 和 B，用空格分隔。',
 '- 输出一个整数，即 A+B。',
 '["1 2"]',
 '["3"]',
 '简单', 1000, 256,
 '- 范围：-1e9 <= A,B <= 1e9\n- 使用 64 位整数存储结果',
 0, 0, '1 2', '3'),

(2, '最大子数组和',
 '给定长度为 n 的整数数组，找到和最大的连续子数组，输出该最大和。\n\n**说明**\n- 子数组必须连续。\n- 至少选择一个元素。',
 '- 第一行一个整数 n。\n- 第二行 n 个整数，表示数组元素。',
 '- 输出最大子数组和。',
 '["9\\n-2 1 -3 4 -1 2 1 -5 4"]',
 '["6"]',
 '中等', 1000, 256,
 '- 1 <= n <= 200000\n- 元素范围 -1e9 到 1e9\n- 可使用 Kadane 线性算法',
 0, 0, '9\n-2 1 -3 4 -1 2 1 -5 4', '6'),

(3, '有效括号',
 '给定仅由 ()[]{} 组成的字符串，判断括号是否成对且顺序正确。\n\n**有效条件**\n- 左括号必须由同类型右括号闭合。\n- 括号必须按正确顺序闭合。',
 '- 一行字符串 s。',
 '- 若有效输出 true，否则输出 false。',
 '["([])"]',
 '["true"]',
 '简单', 1000, 256,
 '- 1 <= |s| <= 100000\n- 使用栈进行匹配',
 0, 0, '([])', 'true'),

(4, '矩阵转置',
 '给定一个 m x n 矩阵，输出其转置矩阵（n x m）。\n\n转置后，第 i 行第 j 列元素变为原矩阵的第 j 行第 i 列。',
 '- 第一行两个整数 m n。\n- 接下来 m 行，每行 n 个整数。',
 '- 输出 n 行，每行 m 个整数，为转置后的矩阵。',
 '["2 3\\n1 2 3\\n4 5 6"]',
 '["1 4\\n2 5\\n3 6"]',
 '简单', 1000, 256,
 '- 1 <= m,n <= 500\n- 注意空格与换行格式',
 0, 0, '2 3\n1 2 3\n4 5 6', '1 4\n2 5\n3 6'),

(5, '二分查找',
 '在一个升序数组中查找目标值 target。\n\n若找到，输出其 0-based 索引；否则输出 -1。',
 '- 第一行两个整数 n 和 target。\n- 第二行 n 个整数，按升序排列。',
 '- 输出目标值的索引或 -1。',
 '["5 7\\n1 3 5 7 9"]',
 '["3"]',
 '简单', 1000, 256,
 '- 1 <= n <= 1000000\n- 数组已升序\n- 使用二分查找 O(log n)',
 0, 0, '5 7\n1 3 5 7 9', '3'),

(6, '合并区间',
 '给定 n 个闭区间 [l, r]，将所有重叠或相邻的区间合并，并按 l 升序输出。',
 '- 第一行一个整数 n。\n- 接下来 n 行，每行两个整数 l r。',
 '- 输出合并后的区间，每行一个 l r。',
 '["4\\n1 3\\n2 6\\n8 10\\n15 18"]',
 '["1 6\\n8 10\\n15 18"]',
 '中等', 1000, 256,
 '- 1 <= n <= 200000\n- 先按 l 排序\n- 若前一个区间右端点 >= 下一个区间左端点，则合并',
 0, 0, '4\n1 3\n2 6\n8 10\n15 18', '1 6\n8 10\n15 18'),

(7, '最小路径和',
 '给定一个 m x n 的非负整数网格，从左上角到右下角，只能向右或向下移动，求路径上的最小和。',
 '- 第一行 m n。\n- 接下来 m 行，每行 n 个非负整数。',
 '- 输出最小路径和。',
 '["3 3\\n1 3 1\\n1 5 1\\n4 2 1"]',
 '["7"]',
 '中等', 1000, 256,
 '- 1 <= m,n <= 200\n- 0 <= grid[i][j] <= 100\n- 使用动态规划',
 0, 0, '3 3\n1 3 1\n1 5 1\n4 2 1', '7'),

(8, '编辑距离',
 '给定两个字符串 s 和 t，你可以对 s 执行插入、删除、替换操作，使其变为 t。\n\n求最少操作数。',
 '- 第一行字符串 s。\n- 第二行字符串 t。',
 '- 输出最小编辑距离。',
 '["kitten\\nsitting"]',
 '["3"]',
 '困难', 1000, 256,
 '- 1 <= |s|, |t| <= 2000\n- dp[i][j] 表示前 i 和前 j 的最小操作数',
 0, 0, 'kitten\nsitting', '3'),

(9, '拓扑排序',
 '给定一个有向无环图 (DAG)，输出**字典序最小**的拓扑序列。\n\n如果多个节点入度为 0，优先选择编号更小的节点。',
 '- 第一行 n m，表示节点数和边数（节点编号从 1 到 n）。\n- 接下来 m 行，每行一条有向边 u v。',
 '- 输出 n 个整数，为字典序最小的拓扑序。',
 '["4 3\\n1 2\\n2 3\\n3 4"]',
 '["1 2 3 4"]',
 '中等', 1000, 256,
 '- 1 <= n <= 200000, 1 <= m <= 300000\n- 使用小根堆维护入度为 0 的节点',
 0, 0, '4 3\n1 2\n2 3\n3 4', '1 2 3 4'),

(10, '最小生成树',
 '给定一个连通无向带权图，求其最小生成树的权值之和。',
 '- 第一行 n m。\n- 接下来 m 行，每行 u v w，表示边及权值。',
 '- 输出最小生成树权值之和。',
 '["4 5\\n1 2 1\\n1 3 4\\n2 3 2\\n2 4 5\\n3 4 3"]',
 '["6"]',
 '中等', 1000, 256,
 '- 1 <= n <= 200000, 1 <= m <= 300000\n- 使用 Kruskal 或 Prim',
 0, 0, '4 5\n1 2 1\n1 3 4\n2 3 2\n2 4 5\n3 4 3', '6'),

(11, '最短路径',
 '给定一个正权图，求从 s 到 t 的最短路径长度。\n\n若不可达，输出 -1。',
 '- 第一行 n m s t。\n- 接下来 m 行，每行 u v w，表示从 u 到 v 的权值为 w 的边。',
 '- 输出最短距离，若不可达输出 -1。',
 '["5 6 1 5\\n1 2 2\\n1 3 4\\n2 3 1\\n2 4 7\\n3 5 3\\n4 5 1"]',
 '["6"]',
 '中等', 1000, 256,
 '- 1 <= n <= 200000, 1 <= m <= 300000\n- 权值均为正\n- 使用 Dijkstra',
 0, 0, '5 6 1 5\n1 2 2\n1 3 4\n2 3 1\n2 4 7\n3 5 3\n4 5 1', '6'),

(12, '最大公约数',
 '给定两个非负整数 a 和 b，输出它们的最大公约数。',
 '- 一行两个整数 a 和 b。',
 '- 输出 gcd(a,b)。',
 '["48 18"]',
 '["6"]',
 '简单', 1000, 256,
 '- 1 <= a,b <= 1e18\n- 使用欧几里得算法',
 0, 0, '48 18', '6'),

(13, '判断回文',
 '判断给定字符串是否为回文串。\n\n回文串从左到右和从右到左完全一致。',
 '- 一行字符串 s（仅包含字母或数字，无空格）。',
 '- 若为回文输出 true，否则输出 false。',
 '["level"]',
 '["true"]',
 '简单', 1000, 256,
 '- 1 <= |s| <= 1000000\n- 双指针从两端向中间',
 0, 0, 'level', 'true'),

(14, '数组旋转',
 '给定数组，将其向右旋转 k 步。\n\n例如 [1,2,3,4,5] 向右旋转 2 步得到 [4,5,1,2,3]。',
 '- 第一行 n k。\n- 第二行 n 个整数。',
 '- 输出旋转后的数组。',
 '["5 2\\n1 2 3 4 5"]',
 '["4 5 1 2 3"]',
 '简单', 1000, 256,
 '- 1 <= n <= 200000\n- k 可能很大，先取 k % n',
 0, 0, '5 2\n1 2 3 4 5', '4 5 1 2 3'),

(15, '逆序对计数',
 '给定一个数组，统计其中逆序对的数量。\n\n若 i < j 且 a[i] > a[j]，则 (i,j) 构成一对逆序对。',
 '- 第一行 n。\n- 第二行 n 个整数。',
 '- 输出逆序对数量。',
 '["5\\n2 3 8 6 1"]',
 '["5"]',
 '困难', 1000, 256,
 '- 1 <= n <= 200000\n- 使用归并排序或树状数组',
 0, 0, '5\n2 3 8 6 1', '5'),

(16, '数位和',
 '给定一个非负整数 N，计算其十进制表示中所有数字之和。',
 '- 一行一个整数 N。',
 '- 输出数字之和。',
 '["12345"]',
 '["15"]',
 '简单', 1000, 256,
 '- 0 <= N <= 1e18\n- 逐位取模累加',
 0, 0, '12345', '15'),

(17, '区间和查询',
 '给定长度为 n 的数组，回答 q 次区间求和查询。\n\n每个查询给出 l r（1-based），输出 a[l..r] 的和。',
 '- 第一行 n q。\n- 第二行 n 个整数。\n- 接下来 q 行，每行 l r。',
 '- 对每个查询输出一行区间和。',
 '["5 3\\n1 2 3 4 5\\n1 3\\n2 5\\n4 4"]',
 '["6\\n14\\n4"]',
 '简单', 1000, 256,
 '- 1 <= n,q <= 200000\n- 使用前缀和',
 0, 0, '5 3\n1 2 3 4 5\n1 3\n2 5\n4 4', '6\n14\n4'),

(18, '岛屿数量',
 '给定由 0 和 1 组成的网格，1 表示陆地，0 表示水域。\n\n相邻（上下左右）陆地连成一个岛屿，求岛屿数量。',
 '- 第一行 m n。\n- 接下来 m 行，每行 n 个数字（0 或 1）。',
 '- 输出岛屿数量。',
 '["3 4\\n1 1 0 0\\n0 1 0 1\\n1 0 0 1"]',
 '["3"]',
 '中等', 1000, 256,
 '- 1 <= m,n <= 500\n- 使用 DFS/BFS 标记访问',
 0, 0, '3 4\n1 1 0 0\n0 1 0 1\n1 0 0 1', '3'),

(19, '最长公共子序列',
 '给定两个字符串 s 和 t，求它们的最长公共子序列长度。\n\n子序列不要求连续，但相对顺序必须一致。',
 '- 第一行字符串 s。\n- 第二行字符串 t。',
 '- 输出最长公共子序列长度。',
 '["abcde\\nace"]',
 '["3"]',
 '中等', 1000, 256,
 '- 1 <= |s|, |t| <= 2000\n- 使用二维 DP',
 0, 0, 'abcde\nace', '3'),

(20, '阶乘末尾零',
 '给定整数 N，计算 N! 末尾连续 0 的个数。\n\nN! 中 0 的数量取决于因子 2 和 5 的数量，且 2 的数量充足。',
 '- 一行一个整数 N。',
 '- 输出末尾 0 的个数。',
 '["25"]',
 '["6"]',
 '中等', 1000, 256,
 '- 0 <= N <= 1e18\n- 统计 N/5 + N/25 + N/125 + ...',
 0, 0, '25', '6');

INSERT INTO problem_tag (problem_id, tag_id) VALUES
(1, 1), (1, 2),
(2, 3), (2, 4),
(3, 5), (3, 6),
(4, 7), (4, 2),
(5, 8), (5, 4), (5, 9),
(6, 10), (6, 11),
(7, 3), (7, 12),
(8, 3), (8, 6),
(9, 13), (9, 14),
(10, 13), (10, 15),
(11, 13), (11, 16),
(12, 17), (12, 18),
(13, 6), (13, 19),
(14, 4), (14, 2),
(15, 20), (15, 21),
(16, 17), (16, 18),
(17, 22), (17, 4),
(18, 23), (18, 24), (18, 13),
(19, 3), (19, 6),
(20, 17), (20, 25);
